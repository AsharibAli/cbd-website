General

Building on Blast

Bridges

Development Toolkits

Web3 Clients

Tools

Big Bang Competition

About Blast

Blast is the only Ethereum L2 with native yield for ETH and stablecoins.

Blast yield comes from ETH staking and RWA protocols. The yield from these decentralized protocols is passed back to Blast users automatically. The default interest rate on other L2s is 0%. On Blast, it’s 4% for ETH and 5% for stablecoins.

​
Why a new L2

After the merge, Ethereum provides 4% yield on ETH. On-chain T-Bill protocols provide 5% yield on stablecoins. If users do not match or beat these rates, they are losing money to a form of inflation.

L2s today do not have this yield. Incorporating ETH and stablecoin yield natively requires a new L2 designed from the ground up. Blast is an EVM-compatible, optimistic rollup that raises the baseline yield for users and developers without changing the experience cryptonatives expect.

This yield makes it possible to create new business models for Dapps that aren’t possible on other L2s.

​
How Blast works

​
Auto Rebasing

ETH itself, not WETH, STETH, or any other ERC20, is natively rebasing on the L2. The ETH balance for EOAs is automatically rebasing. Smart contracts can opt-in to this rebasing, making it easy to existing Dapps to deploy on Blast without any changes.

USDB, Blast’s native stablecoin, is automatically rebasing as well. Like ETH on Blast, USDB is automatically rebasing for EOAs. USDB is also automatically rebasing for smart contracts. Smart contracts can opt-out from this rebasing.

​
L1 Staking

Blast only became possible following Ethereum’s Shanghai upgrade. ETH yield from L1 staking, initially Lido, is automatically transferred to users via rebasing ETH on the L2.

In the future, the Blast community will have the power to supplement, or even fully replace, Lido Blast-native solutions or other third party protocols.

​
T-Bill Yield

Users who bridge stablecoins receive USDB, Blast’s auto-rebasing stablecoin. The yield for USDB comes from MakerDAO’s on-chain T-Bill protocol. USDB can be redeemed for USDC when bridging back to Ethereum.

In the future, the Blast community will have the power to supplement, or even fully replace, MakerDAO with Blast-native solutions or other third party protocols.

​
Gas Revenue Sharing

Other L2s keep revenue from gas fees for themselves. Blast gives net gas revenue back to Dapps programatically. Dapps developers can keep this revenue for themselves or use it to subsidize gas fees for users.


To add Blast Sepolia as a custom network to MetaMask:
1.Go to the Blast Testnet Explorer at testnet.blastscan.io
2.Scroll to the bottom and click the Add Blast Testnet Sepolia Network button in the footer.
3.Approve adding the network in the MetaMask prompt that opens.
MetaMask Manual Instructions
To add Blast Sepolia as a custom network to MetaMask:
1.Open the MetaMask browser extension.
2.Open the network selection dropdown menu by clicking the dropdown button at the top of the
extension.
3.Click the Add network button.
4.Click Add a network manually.
5.In the Add a network manually dialog that appears,enter the following information for the Blast
Sepolia testnet.
Network Name:Blast Sepolia
RPC Endpoint:https://sepolia.blast.io
Chain ID:168587773
Currency Symbol:ETH
Block Explorer:https://testnet.blastscan.io
6.Tap the Save button to save Blast Sepolia as a network.
You should now be able to connect to the Blast testnet by selecting it from the network selection
dropdown menu.

Network Information
​
Blast Mainnet
The Blast Mainnet is coming late February.

​
Blast Testnet (Sepolia)
Network Name: Blast Sepolia
RPC Endpoint: https://sepolia.blast.io
Chain ID: 168587773
Currency Symbol: ETH
Block Explorer: https://testnet.blastscan.io

Building on Blast
Blast Contracts
​
Mainnet
The Blast mainnet is coming late February.

​
Testnet
​
L1 Contract Addresses
L1BlastBridgeProxy: 0xc644cc19d2A9388b71dd1dEde07cFFC73237Dca8

L1StandardBridgeProxy: 0xDeDa8D3CCf044fE2A16217846B6e1f1cfD8e122f

L1ERC721BridgeProxy: 0x993385F8A2aD69dfa0884287801191DE9805Ff37

L1CrossDomainMessengerProxy: 0x9338F298F29D3918D5D1Feb209aeB9915CC96333

OptimismPortalProxy: 0x2757E4430e694F27b73EC9C02257cab3a498C8C5

ETHYieldManagerProxy: 0xed530ba33b4dc14572864bb9a776c9a42cf89fa5

L2OutputOracleProxy: 0x311fF72DfE214ADF97618DD2E731637E8F41bD8c

SystemConfigProxy: 0x329faF078c364A316e08Bf6A17B7Eee6ae75a613

TestnetYieldProvider: 0x26B1B9Ff3A25a7D6e4468fA94696e45d066c7d08

​
L2 Contract Addresses
L2ToL1MessagePasser: 0x4200000000000000000000000000000000000016

L2CrossDomainMessenger: 0x4200000000000000000000000000000000000007

L2StandardBridge: 0x4200000000000000000000000000000000000010

OptimismMintableERC20Factory: 0x4200000000000000000000000000000000000012

L2ERC721Bridge: 0x4200000000000000000000000000000000000014

OptimismMintableERC721Factory: 0x4200000000000000000000000000000000000017

USDB: 0x4200000000000000000000000000000000000022

WETHRebasing: 0x4200000000000000000000000000000000000023

L2BlastBridge: 0x4200000000000000000000000000000000000024

Building on Blast
Bridged Token Addresses
​
Mainnet
The Blast mainnet is coming late February.

​
Testnet
WETH: 0x4200000000000000000000000000000000000023

USDB: 0x4200000000000000000000000000000000000022

USDB is deployed, but not currently live on the Blast Sepolia testnet. USDB is expected to go live on the testnet around January 22.

Building on Blast
Transaction Finality
The status of transactions on Blast varies based on where they are in the process of being included in the blockchain.

​
Pending
Instant after being sent to Sequencer

Right after being sent to the Sequencer, a transaction is categorized as “pending” until it gets included in a block. This initial status indicates that the transaction hasn’t become part of the blockchain yet, and there’s no assurance of its inclusion.

To obtain a list of all pending transactions, you can use the standard JSON-RPC method eth_getBlockByNumber with the block number parameter set to pending.

​
Sequencer Confirmed / Unsafe
Typically within 2-4 seconds

A transaction is labeled as “sequencer confirmed” or “unsafe” once it’s been included in a block by the Sequencer, but that block hasn’t been published to Ethereum yet. Despite being in a block, there’s still a chance for the transaction to be excluded from the final blockchain if the Sequencer doesn’t publish the block promptly. Applications should be mindful of this possibility when presenting information about transactions in this state.

To obtain the latest “sequencer confirmed” block, use the standard JSON-RPC method eth_getBlockByNumber with the block number parameter set to safe. Compare this with the result returned for the latest block. If the safe block lags behind the latest block, the earliest “sequencer confirmed” block is the safe block plus one.

​
Published to Ethereum / Safe
Typically within 5-10 minutes, up to 24 hours

A transaction is deemed “safe” when it has been included in a block by the Sequencer, and that block has been published to Ethereum, but that block is not yet finalized. Once a block is published to Ethereum, there is a high likelihood of it being included in the final blockchain. However, there is still a possibility of a re-org.

To get the latest “safe” block, use the standard JSON-RPC method eth_getBlockByNumber with the block number parameter set to safe.

Transactions usually become “safe” status within a few minutes of being “sequencer confirmed.”

​
Finalized
Typically within 15-20 minutes, up to 24 hours

A transaction is “finalized” when it has been included in a block by the Sequencer, that block has been published to Ethereum, and that block has been finalized.

The latest “finalized” block can be retrieved by calling the standard JSON-RPC method eth_getBlockByNumber with the parameter finalized as the block number.

Bridges
Mainnet
The mainnet bridge will be available when the Blast Mainnet launches in late February.

Bridges
Testnet
​
How to deposit to Blast
​
Overview
To deposit ETH and other tokens to Blast, simply transfer the token to the relevant Blast Bridge address on the L1.

After the deposit transaction is mined, the balance will be credited on the L2 as soon as the Blast Sequencer indexes the transaction.

​
ETH
Transfer ETH via the tool of your choice to the following bridge address on Ethereum Sepolia: 0xc644cc19d2A9388b71dd1dEde07cFFC73237Dca8

​
WETH, STETH, USDC, USDT, DAI
Depositing Ethereum Sepolia WETH, STETH, USDC, USDT, DAI will be supported in the future, but is currently not supported on the Blast Sepolia testnet.

Blast Sepolia ETH can be wrapped to WETH directly on the L2 (see Foundry example below).

​
Other tokens
Blast supports bridging arbitrary tokens in a similar manner to Optimism. Refer to the Optimism docs to learn how to bridge arbitrary tokens.

Bridge address for arbitrary ERC20 tokens (L1StandardBridge): 0xDeDa8D3CCf044fE2A16217846B6e1f1cfD8e122f

Bridge address for arbitrary ERC721 tokens (L1ERC721Bridge): 0x993385F8A2aD69dfa0884287801191DE9805Ff37

​
Deposit via UI
Coming soon

​
Deposit programmatically
You can use any tool/wallet to send the transfer transaction to the Blast Bridge address. Here are some examples:

​
Foundry
The following code snippet shows how to use Foundry’s cast tool to send ETH from Ethereum Sepolia to Blast Sepolia, and then convert that ETH to WETH.


# Depositing Sepolia ETH 
cast send -i 0xc644cc19d2A9388b71dd1dEde07cFFC73237Dca8 --value 0.1ether --rpc-url https://sepolia.infura.io/v3/$INFURA_KEY

# Confirming the bridged ETH on Blast
cast balance $YOUR_ADDRESS --rpc-url https://sepolia.blast.io

# Converting to WETH (Rebasing)
cast send -i 0x4200000000000000000000000000000000000023 --value 0.1ether --rpc-url https://sepolia.blast.io 
​
ethers.js
The following code snips shows how to use ethers.js to send ETH from Ethereum Sepolia to Blast Sepolia.


const { ethers } = require("ethers");

const INFURA_KEY = "YOUR_INFURA_KEY";
const PRIVATE_KEY = "YOUR_PRIVATE_KEY";

const BlastBridgeAddress = "0xc644cc19d2A9388b71dd1dEde07cFFC73237Dca8";

// Providers for Sepolia and Blast networks
const sepoliaProvider = new ethers.providers.JsonRpcProvider(`https://sepolia.infura.io/v3/${INFURA_KEY}`);
const blastProvider = new ethers.providers.JsonRpcProvider("https://sepolia.blast.io");

// Wallet setup
const wallet = new ethers.Wallet(PRIVATE_KEY);
const sepoliaWallet = wallet.connect(sepoliaProvider);
const blastWallet = wallet.connect(blastProvider);

// Transaction to send 0.1 Sepolia ETH
const tx = {
    to: BlastBridgeAddress,
    value: ethers.utils.parseEther("0.1")
};

const transaction = await sepoliaWallet.sendTransaction(tx);
await transaction.wait();

// Confirm the bridged balance on Blast
const balance = await blastProvider.getBalance(wallet.address);
console.log(`Balance on Blast: ${ethers.utils.formatEther(balance)} ETH`);
​
How to withdraw from Blast
Withdrawals from Blast require multiple steps. The process is similar to withdrawing from Optimism. Withdrawals take approximately 14 days to complete. Detailed instructions/code samples coming soon.

FAQ:
How long does it take to transfer from Ethereum mainnet to Blast?
Transferring from Ethereum to Blast only takes a few minutes.

How long does it take to transfer from Blast to Ethereum mainnet?
Transferring from Blast to Ethereum takes approximately 14 days. This is a security feature designed to help secure Blast.

Development Toolkits
Foundry
Foundry is a fast, portable and modular toolkit for Ethereum application development written in Rust.

Foundry consists of:

Forge: Ethereum testing framework (like Truffle, Hardhat and DappTools).
Cast: Swiss army knife for interacting with EVM smart contracts, sending transactions and getting chain data.
Anvil: Local Ethereum node, akin to Ganache, Hardhat Network.
Chisel: Fast, utilitarian, and verbose solidity REPL.
​
Testnet
​
Deploying a smart contract

forge create ... --rpc-url=https://sepolia.blast.io
​
Verifying a smart contract

forge verify-contract ... --chain-id 168587773

Development Toolkits
Hardhat
Hardhat is an Ethereum development environment for professionals. It facilitates performing frequent tasks, such as running tests, automatically checking code for mistakes or interacting with a smart contract.

​
Using Hardhat with Blast

networks: {
   // for mainnet
   "blast-mainnet": {
     url: "coming end of February",
     accounts: [process.env.PRIVATE_KEY as string],
     gasPrice: 1000000000,
   },
   // for Sepolia testnet
   "blast-sepolia": {
     url: "https://testnet.blast.io",
     accounts: [process.env.PRIVATE_KEY as string]
     gasPrice: 1000000000,
   },
   // for local dev environment
   "blast-local": {
     url: "http://localhost:8545",
     accounts: [process.env.PRIVATE_KEY as string],
     gasPrice: 1000000000,
   },
 },
 defaultNetwork: "blast-local",


Web3 Clients
ethers.js
You can connect to Blast by instantiating a new ethers.js JsonRpcProvider object with a RPC URL of the Blast network.

​
Mainnet
See Testnet instructions. The Blast Mainnet RPC URL will be provided when the Mainnet launches near the end of February.

​
Testnet

const ethers = require('ethers'); // ethers v6
const url = 'https://sepolia.blast.io';
const provider = new ethers.JsonRpcProvider(url);


Web3 Clients
web3.js
You can connect to Blast by instantiating a new web3.js Web3 object with a RPC URL of the Blast network.

​
Mainnet
See Testnet instructions. The Blast Mainnet RPC URL will be provided when the Mainnet launches near the end of February.

​
Testnet

const { Web3 } = require('web3');

const web3 = new Web3('https://sepolia.blast.io');

Building on Blast
Receive and claim ETH yield
​
Overview
Blast is an L2 that modifies the native ETH token to be rebasing. Blast users and smart contracts can earn ~4% from beacon chain staking yield.

EOAs automatically receive ETH yield via rebasing.

Smart contract accounts have three Yield Modes for their rebasing mode:

Void (DEFAULT): ETH balance never changes; no yield is earned
Automatic: native ETH balance rebases (increasing only)
Claimable: ETH balance never changes; yield accumulates separately
Smart contracts must interact with the Blast yield contract located at 0x4300000000000000000000000000000000000002 to change their Yield Mode.

​
Yield Modes
​
Void Yield (DEFAULT)
Smart contract accounts default to Disabled yield in order to maintain compatibility with existing Ethereum Mainnet dapps and EVM-compatible L2 dapps. Any normal dapp can be deployed to Blast and Just Work™ without any changes needed.

​
Automatic Yield
If 1 ETH is deposited to a dapp with Automatic yield enabled, the dapp’s balance will grow to 1.04 ETH in a year. This is useful for dapps that want to pass yield on to their users such that there’s no opportunity cost for the user to deposit ETH to the dapp.


interface IBlast{
    // See IBlast interface source code below
}

contract MyContract {
	constructor() {
		IBlast(0x43...02).configureAutomaticYield() //contract balance will grow automatically
	}
}
​
Claimable Yield
If 1 ETH is deposited to a dapp with Claimable yield enabled, the dapp’s balance will remain at 1 ETH even after a year. The dapp will accrue a yield balance of 0.04 ETH which can be claimed asynchronously.


interface IBlast{
    // See IBlast interface source code below
}

contract MyContract {
	constructor() {
		IBlast(0x43...02).configureClaimableYield()
	}

	function claimYield(address recipient, uint256 amount) external {
	  //This function is public meaning anyone can claim the yield
		IBlast(0x43...02).claimYield(address(this), recipient, amount);
  }

	function claimAllYield(address recipient) external {
	  //This function is public meaning anyone can claim the yield
		IBlast(0x43...02).claimAllYield(address(this), recipient);
  }
}
​
Governor
The governor is the address that’s allowed to claim the contract’s yield and gas, which might be the contract’s own address, its owner, or anything else.

By default, the governor is the contract’s own address.

After contract creation, only the governor can reconfigure the contract’s yield and gas mode.


interface IBlast{
    // See IBlast interface source code below
}

contract MyContract {
	constructor(address gov) {
		IBlast(0x43...02).configureClaimableYield() 
		IBlast(0x43...02).configureGovernor(gov) //only this address can claim yield
	}
}
​
FAQ
​
Can an EOA forward its yield to another address?
An Automatic yield mode EOA or contract cannot forward its yield to another account. On yield distribution events, the balance of an automatically rebasing account will automatically increase.

A Claimable account’s yield is not counted as part of the EVM balance. The yield must be claimed via the Blast pre-deploy’s claimYield() or claimAllYield() functions. Both these interfaces allow the caller to specify a recipient for the yield. In this way, yield accumulating to a Claimable account can be claimed to another address directly. Note that this does not happen automatically — a contract call must be made to claim. Additionally, an EOA can set its governor to another address, which would allow that address to make these claimYield calls without any interactions from the EOA.

​
How often do balances update due to yield?
On mainnet, ETH balances will update approximately daily. On testnet, ETH balances will update hourly at a rate of ~0.01% per day.

​
IBlast Interface

enum YieldMode {
    AUTOMATIC,
    VOID,
    CLAIMABLE
}

enum GasMode {
    VOID,
    CLAIMABLE 
}

interface IBlast{
    // configure
    function configureContract(address contractAddress, YieldMode _yield, GasMode gasMode, address governor) external;
    function configure(YieldMode _yield, GasMode gasMode, address governor) external;

    // base configuration options
    function configureClaimableYield() external;
    function configureClaimableYieldOnBehalf(address contractAddress) external;
    function configureAutomaticYield() external;
    function configureAutomaticYieldOnBehalf(address contractAddress) external;
    function configureVoidYield() external;
    function configureVoidYieldOnBehalf(address contractAddress) external;
    function configureClaimableGas() external;
    function configureClaimableGasOnBehalf(address contractAddress) external;
    function configureVoidGas() external;
    function configureVoidGasOnBehalf(address contractAddress) external;
    function configureGovernor(address _governor) external;
    function configureGovernorOnBehalf(address _newGovernor, address contractAddress) external;

    // claim yield
    function claimYield(address contractAddress, address recipientOfYield, uint256 amount) external returns (uint256);
    function claimAllYield(address contractAddress, address recipientOfYield) external returns (uint256);

    // claim gas
    function claimAllGas(address contractAddress, address recipientOfGas) external returns (uint256);
    function claimGasAtMinClaimRate(address contractAddress, address recipientOfGas, uint256 minClaimRateBips) external returns (uint256);
    function claimMaxGas(address contractAddress, address recipientOfGas) external returns (uint256);
    function claimGas(address contractAddress, address recipientOfGas, uint256 gasToClaim, uint256 gasSecondsToConsume) external returns (uint256);

    // read functions
    function readClaimableYield(address contractAddress) external view returns (uint256);
    function readYieldConfiguration(address contractAddress) external view returns (uint8);
    function readGasParams(address contractAddress) external view returns (uint256 etherSeconds, uint256 etherBalance, uint256 lastUpdated, GasMode);
}

Building on Blast
Receive and claim WETH and USDB yield
Similar to ETH, WETH and USDB on Blast is also rebasing and follows the same yield mode configurations.

However, unlike ETH where contracts have Disabled yield by default, WETH and USDB accounts have Automatic yield by default for both EOAs and smart contracts.

Users can change the yield mode of their WETH and USDB accounts by calling the configure function on the relevant token address.


enum YieldMode {
    AUTOMATIC,
    VOID,
    CLAIMABLE
}

interface IWETHUSDBRebasing {
    // changes the yield mode of the caller and update the balance
    // to reflect the configuration
    function configure(YieldMode) external returns (uint256);
}

contract MyContract {
		constructor(address gov) {
              IWETHUSDBRebasing(0x42...22).configure(YieldMode.CLAIMABLE) //configure claimable yield for USDB
			  IWETHUSDBRebasing(0x42...23).configure(YieldMode.CLAIMABLE) //configure claimable yield for WETH
		}
}
The WETH and USDB addresses will be slightly different on the Blast mainnet.

USDB is deployed, but not currently live on the Blast Sepolia testnet. USDB is expected to go live on the testnet around January 22.

Building on Blast
Receive and claim gas fees
​
Overview
Existing L2s like Optimism and Arbitrum keep sequencer fees for themselves. Blast redirects sequencer fees to the dapps that induced them, allowing smart contract developers to have an additional source of revenue.

Contracts have two options for their Gas Mode:

Void (DEFAULT): base + priority fees go to the sequencer operator
Claimable: base + priority fees spent on this contract can be claimed by the contract, net of L1 fees
Smart contracts must interact with the Blast contract located at 0x4300000000000000000000000000000000000002 to change their Gas Mode.

​
Setting Gas Mode to Claimable
The entity that is allowed to claim the gas fees spent on a contract is known as its “governor”. By default, the governor of a smart contract is the contract itself. The following example sets the Gas Mode to claimable and exposes a function to allow anybody to claim this contract’s gas fees.


interface IBlast {
  // Note: the full interface for IBlast can be found below
  function configureClaimableGas() external;
  function claimAllGas(address contractAddress, address recipient) external returns (uint256);
}

contract MyContract {
  IBlast public constant BLAST = IBlast(0x4300000000000000000000000000000000000002);

  constructor() {
    // This sets the Gas Mode for MyContract to claimable
    BLAST.configureClaimableGas(); 
  }

  // Note: in production, you would likely want to restrict access to this
  function claimMyContractsGas() external {
    BLAST.claimAllGas(address(this), msg.sender);
  }
}
Alternatively, you can specify an external governor. Once the governor is changed away from the contract itself, only the governor can set the gas mode, claim gas fees, and reconfigure the governor. In the following example, the governor could be an EOA belonging to the contract creator or another smart contract.


interface IBlast {
  // Note: the full interface for IBlast can be found below
  function configureClaimableGas() external;
  function configureGovernor(address governor) external;
}

contract MyContract {
  IBlast public constant BLAST = IBlast(0x4300000000000000000000000000000000000002);

  constructor(address governor) {
    BLAST.configureClaimableGas();
    // This sets the contract's governor. This call must come last because after
    // the governor is set, this contract will lose the ability to configure itself.
    BLAST.configureGovernor(governor); 
  }
}
The governor now has the ability to claim the gas fees for this contract by sending a claimAllGas transaction to the Blast contract.


BLAST.claimAllGas(myContractAddress, recipient);
​
Claiming Gas Fees
If you claim the gas fees for a contract immediately after the fees are earned, then 50% of the fees will be sent to the claim recipient and 50% will be sent to the sequencer operator. This is known as the “claim rate”, and it starts at 50% and increases to 100% over time. For mainnet, the parameters will be set to a 50% initial claim rate, 30 day maturity period, and 100% final claim rate.

You can think of each transaction’s gas fees as having their own claim rate that evolves independently. As an example, suppose you have 1 ETH in fees from January 1st and 1 ETH in fees from January 15th. When you claim 1 month later on February 1st, you’ll be able to claim 100% of your January 1st fees and 75% of your January 15th fees. Only half a month has passed since your January 15th fees, so the claim rate has increased halfway to its max potential, from 50% to 75%. Your average claim rate for the full 2 ETH of fees will be the weighted average of these two claim rates: 87.5%.

Thinking about the effective claim rate can get very confusing when you have many transactions over time, so for convenience, there are a handful of utility methods to make the claiming process easy.

​
claimAllGas

function claimAllGas(address contractAddress, address recipient) external returns (uint256);
To claim all of your contract’s gas fees, regardless of your resulting claim rate, you can call claimAllGas. Your resulting claim rate may be anywhere from 50% to 100% depending on how long it has been since the fees were earned.

​
claimMaxGas

function claimMaxGas(address contractAddress, address recipient) external returns (uint256);
If you’d like to maximize the amount of gas fees claimed and you’re okay waiting for the fees to mature, then you can use claimMaxGas to guarantee a 100% claim rate. By guaranteeing the claim rate, you may not be able to claim all of your gas fees though. Any remaining fees after calling this function will remain in the Blast Gas contract for you to claim later.

​
claimGasAtMinClaimRate

function claimGasAtMinClaimRate(
  address contractAddress,
  address recipient,
  uint256 minClaimRateBips
) external returns (uint256);
This helper allows you to claim the maximum amount of gas fees while guaranteeing a specific claim rate. If you’re comfortable with an 80% claim rate, that translates to 8000 bips, so you would call claimGasAtMinClaimRate(contractAddress, recipient, 8000). Calling this function with a 100% min claim rate is the same as calling claimMaxGas.

​
How Gas Fees Are Allocated
The gas fees spent on Blast transactions can be broken up into three components: L1 data availability fees, L2 base fees, and L2 priority fees. The L1 data availability fee ensures that other nodes can trustlessly recovery the state of the Blast L2, and it gets burned on the Ethereum L1. The L2 base and priority fees (“sequencer fees”) however either go to the sequencer operator or to the smart contracts that caused the gas to be spent.

Blast allocates sequencer fees to contracts based on the amount of gas that contract consumed in the transaction. This means that contracts that make nested calls to other smart contracts will get a proportional amount of the total gas fees spent on the transation, not the total amount. Consider the following example transaction:

Contract A (30,000 gas)
Contract B (50,000 gas)
Contract C (20,000 gas)
Contract A (30,000 gas)
Contract D (40,000 gas)
Suppose that only contracts A and D have set their Gas Mode to claimable. In this sample transaction, contract A would be allocated 30,000 + 30,000 = 60,000 gas worth of fees, and contract D would be allocated 40,000 gas worth of fees. The gas spent on contracts B and C, 50,000 + 20,000 = 70,000, would be allocated to the sequencer operator.

To determine the amount of ETH that contract A would receive for this transaction, you need to multiply the gas amount by the gas price. If the gas price for this transaction was 15 gwei (10 gwei base + 5 gwei priority), then the ETH amount contract A would receive would be 60,000 gas * 15 gwei/gas = 0.0009 ETH.

​
How Gas Fees and Claim Rates Are Tracked
This section contains low level details on how the Blast Gas contract works. You don’t need to read or understand this section to configure your contracts or claim your gas, but if you’re interested in a optimizing your integration, or just a bit curious, read on.

The Blast Gas contract keeps track of the integral of your contract’s unclaimed fees over time. If you had 1 ETH of unclaimed fees for 1 day, the resulting integral would be 1 ether-day. If you instead had 2 ETH of unclaimed fees for 1 week, then the integral would be 14 ether-days.

To make this integration process clear, let’s build on top of this second scenario. If you suddenly accumulated 1 additional ETH of fees, your contract’s unclaimed fee balance would be 3 ETH, but the integral would still be 14 ether-days. If you waited 1 more day, then the integral would be 17 ether-days. The Blast Gas contract uses this integral to determine the effective maturity of your unclaimed fee balance.

​
Blast Gas Claim Parameters
There are five parameters that determine how your contract’s accumulated ether-days relates to your claim rate:

zeroClaimRate: your claim rate immediately after earning gas fees
baseGasSeconds: the number of seconds your gas fees need to mature to receive the baseClaimRate
ceilGasSeconds: the number of seconds your gas fees need to mature to receive the ceilClaimRate
Represented visually, this looks like:

Abstract gas parameters
The intended mainnet parameters look like this:

Abstract gas parameters
​
Custom Gas Fee Claims
The following function is the lowest level claim helper. It allows you to specify exactly how much ETH you’d like to claim and how many ether-seconds you’d like to use to contribute to your claim rate.


function claimGas(
  address contractAddress,
  address recipient,
  uint256 etherToClaim,
  uint256 etherSecondsToConsume
) external returns (uint256);
Claiming 1 ETH at the ceilClaimRate requires ceilGasSeconds ether-seconds. Providing fewer ceilGasSeconds than this would result in an effective claim rate less than the ceilClaimRate, based on the zeroClaimRate and baseClaimRate parameters.

​
IBlast Interface

enum YieldMode {
    AUTOMATIC,
    VOID,
    CLAIMABLE
}

enum GasMode {
    VOID,
    CLAIMABLE 
}

interface IBlast {
    // configure
    function configureContract(address contractAddress, YieldMode _yield, GasMode gasMode, address governor) external;
    function configure(YieldMode _yield, GasMode gasMode, address governor) external;

    // base configuration options
    function configureClaimableYield() external;
    function configureClaimableYieldOnBehalf(address contractAddress) external;
    function configureAutomaticYield() external;
    function configureAutomaticYieldOnBehalf(address contractAddress) external;
    function configureVoidYield() external;
    function configureVoidYieldOnBehalf(address contractAddress) external;
    function configureClaimableGas() external;
    function configureClaimableGasOnBehalf(address contractAddress) external;
    function configureVoidGas() external;
    function configureVoidGasOnBehalf(address contractAddress) external;
    function configureGovernor(address _governor) external;
    function configureGovernorOnBehalf(address _newGovernor, address contractAddress) external;

    // claim yield
    function claimYield(address contractAddress, address recipientOfYield, uint256 amount) external returns (uint256);
    function claimAllYield(address contractAddress, address recipientOfYield) external returns (uint256);

    // claim gas
    function claimAllGas(address contractAddress, address recipientOfGas) external returns (uint256);
    function claimGasAtMinClaimRate(address contractAddress, address recipientOfGas, uint256 minClaimRateBips) external returns (uint256);
    function claimMaxGas(address contractAddress, address recipientOfGas) external returns (uint256);
    function claimGas(address contractAddress, address recipientOfGas, uint256 gasToClaim, uint256 gasSecondsToConsume) external returns (uint256);

    // read functions
    function readClaimableYield(address contractAddress) external view returns (uint256);
    function readYieldConfiguration(address contractAddress) external view returns (uint8);
    function readGasParams(address contractAddress) external view returns (uint256 etherSeconds, uint256 etherBalance, uint256 lastUpdated, GasMode);
}

Tools
Node Providers
​
Quicknode
Quicknode provides public and private rpc endpoints for Blast, along with websocket support.

​
Supported Networks
Blast Mainnet (coming end of February)
Blast Sepolia (testnet)
​
Ankr
Ankr provides public and private rpc endpoints for Blast.

​
Supported Networks
Blast Mainnet (coming end of February)
Blast Sepolia (testnet)
​
Infura
Infura provides public and private rpc endpoints for Blast.

​
Supported Networks
Blast Mainnet (coming soon)
Blast Sepolia (coming soon)

Tools
Block Explorers
​
Routescan
Mainnet (coming end of February)
Testnet - https://testnet.blastscan.io
​
Etherscan
Mainnet (coming soon)
Testnet (coming soon)

Tools
Faucets
​
Blast Sepolia Faucet
​
Quicknode
QuickNode Blast Faucet is an easy to use Multi-Chain Faucet that drips Blast Sepolia ETH.

​
Ethereum Sepolia Faucet
You can get Ethereum Sepolia ETH and transfer it to use on Blast Sepolia by sending Sepolia ETH to the Blast L1StandardBridge as done here.

​
Quicknode
QuickNode Ethereum Faucet is an easy to use Multi-Chain Faucet that drips Ethereum Sepolia ETH.

Tools
Oracles
​
Pyth
Pyth offers 400+ pull-based price feeds for Blast.

Pyth also offers on-chain randomness on Blast via their Entropy protocol.

Learn how to use Pyth feeds with this guide.

​
Supported Networks
Blast Mainnet (coming end of February)
Blast Sepolia (Testnet)
​
Redstone
Redstone offers push-based price feeds for Blast.

Learn how to use Redstone feeds with this guide.

​
Supported Networks
Blast Mainnet (coming end of February)
Blast Sepolia (Testnet)

Tools
Data Indexers
​
The Graph
The Graph is an indexing protocol for organizing blockchain data and making it easily accessible with GraphQL.

Blast dapps can use GraphQL to query open APIs called subgraphs, to retrieve data that is indexed on the network.

Learn how to use The Graph via their documentation or this quickstart.

​
Supported Networks
Blast Mainnet (coming end of February)
Blast Sepolia (Testnet)

Big Bang Competition
FAQ

Can teams that have already completed fundraising still participate?

Yes! The Big Bang competition is open to both early stage teams that are just starting out with an idea as well as late stage teams looking to get in front of the Blast community. Late and early stage teams will be judged separately.


Are we allowed to join the competition with multiple projects?

You can join with multiple projects but know that you will be competing with projects who are focused on nailing a single submission.


Are the winners of the competition the only ones eligible for the developer airdrop?

A portion of the Blast Developer Airdrop is reserved for competition winners, and a portion is reserved for Mainnet dapps. The exact split has not been revealed but the vast majority of the airdrop is reserved for Mainnet dapps (ie 90%+).


Do users receive anything for participating in the testnet?

Users don’t receive anything for participating in the testnet, but stay tuned for the Mainnet!


Are teams guaranteed 1:1 office hours with Pacman and the other advisors?

Pacman and the rest of the advisors will work on a best effort basis to schedule 1:1 time with every team that expresses interest. At minimum every team is expected to get personalized advice asynchronously in their personal Blast Builders slack channel.


How much % of the developer airdrop is going towards the winners?

The exact percentage going towards winners will not be disclosed but it will be the largest individual allocation of points to date.


Can we give developer airdrop points back to our users?

Absolutely. Giving back developer points to your own users will allow you to bootstrap liquidity and users without having to use your own native token. We encourage dapps to explore incentive design with the Blast team to effectively use the airdrop for long-term growth.


Does my dApp need to be deployed to testnet to submit?

Yes. Your dApp needs to be live on the Blast Sepolia testnet. It does not need to be feature complete however.


Can I submit as an anon, DAO, independent contributor?

Yes. You can submit anonymously, as an independent contributor or as a DAO.


Do I need to have a legal entity or incorporation?

It is not required to have a legal entity or incorporation to participate in the Big Bang competition. Please make sure you read our rules.


Am I more likely to win if I am already funded?

Funding is not a judging criteria and late stage projects are judged separately from early stage projects.


What is the difference between Late Stage and Early Stage projects?

While there is no specific criteria, generally Early Stage projects are projects that have little funding or just started building (either after the competition started or shortly before). Late Stage projects are either already launched on other chains or many months into development. It is up to the discretion of the competition administrators to determine whether projects that fall in the middle of the spectrum are Late Stage or Early Stage.


I don’t speak English well, can I submit my project in my 1st language?

If you would like to submit your project in your native language that’s completely fine and we can organize a live translation for the live stream at the end of the competition.

Big Bang Competition
Ideas
Yield = Blast native yield on ETH and USDB + Blast Points. Deposits to smart contracts earn Blast Points as well on Mainnet.
Developers will also be able to earn Blast Developer Points on Mainnet. Developers are encouraged to pass these points to their users in incentive campaigns to bootstrap their own network effects.
​
Perp Dexes
Perp dex that passes yield on deposits (USDB, ETH, WETH) to users
Perp dex that monetizes via yield on deposits and gas fees, and charges zero trading fees (“Robinhood for perp dexes”)
Perp dex that passes yield and gas fees to top traders in a lottery style distribution (use the trading volume as the weight for the random distribution)
Perp dex that passes yield from takers to makers
Perp dex that passes yield, gas fees, and trading fees to token holders
Perp dex that passes yield from users to vault depositors, boosting the baseline yield of LPs beyond the normal yield
​
Spot Dexes
Spot dexes that passes yield on LP positions to LPs
Spot dex that rebalances LP positions with the yield accumulated
Spot dex that awards traders with the yield from LP positions (ie in a lottery-style distribution that uses trading volume as the randomness weight)
Spot dex that passes yield from LPs and gas fee revenue to frontend administrators and token holders, enabling zero trading fees forever (ie avoid the Uniswap problem)
​
Lending Protocols
Lending protocol that gives yield from borrower collateral positions to lenders, improving capital efficiency for borrowers
Lending protocol that adds yield from borrower collateral positions onto those same positions, improving debt health automatically
Lending protocol that adds yield from LP positions onto those same LP positions, improving liquidity automatically and reducing opportunity costs for lenders
​
NFTs/Gaming
NFT where mint is done via a bonding curve. Monetize the yield on deposits and align incentives between creators and NFT holders (all benefit when number goes up).
NFT where net gas fees go to creator, maximizing creator earnings
NounsDAO but treasury grows automatically via yield
New NFT mint mechanics where mint price is yield by holding deposits in escrow, effectively making the NFT mint “free”
On-chain games where price to play is holding user deposits in escrow and earning yield on deposits (making the game free to play for users)
NFT perpetual product that passes yield on deposits to users
​
SocialFi
FriendTech but pass the yield onto users, reducing opportunity cost of depositing
FriendTech but instead of trading fees, the platform and creators monetize through yield, which improves liquidity and aligns incentives between the platform, creators, and key holders
​
GambleFi
Onchain daily fantasy sports where the platform monetizes through yield and not rake. Making game fairer for players with more upside
Poker where the platform monetizes through yield and not rake. Making game fairer for players with more upside
On-chain coin flip game where platform monetizes through yield and not a rake, making gameplay fairer for players with more upside
PoolTogether but give the native yield + Blast Points accrued to the winner
​
Infrastructure
Solidity libraries that make it easy for developers to pass yield on deposits to users, reducing the opportunity cost for users to deposit into dapps
TG bots that charge zero trading fees and instead monetize through users’ yield, enabling them to be more competitive than existing TG bots
​
Miscellaneous
Anything goes. Surprise us!
